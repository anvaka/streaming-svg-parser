{
  "version": 3,
  "sources": ["../lib/createStreamingSVGParser.js", "../lib/NumberParser.js", "../lib/getPointsFromPathData.js", "../lib/getElementFillColor.js", "../index.js"],
  "sourcesContent": ["\n// Possible states of SVG parsing\nconst WAIT_TAG_OPEN = 1;\nconst READ_TAG_OR_COMMENT = 2;\nconst READ_TAG = 3;\nconst READ_TAG_CLOSE = 4;\nconst READ_COMMENT = 5;\nconst WAIT_TAG_CLOSE = 6;\nconst WAIT_ATTRIBUTE_OR_CLOSE_TAG = 7;\nconst READ_ATTRIBUTE_NAME = 8;\nconst READ_ATTRIBUTE_VALUE = 9;\nconst WAIT_ATTRIBUTE_VALUE = 10;\nconst WAIT_ATTRIBUTE_ASSIGNMENT_OR_NEXT_ATTRIBUTE = 11;\n\nconst A = 'A'.charCodeAt(0);\nconst Z = 'z'.charCodeAt(0);\nconst whitespace = /\\s/;\n\n/**\n * Creates a new instance of the parser. Parser will consume chunk of text and will\n * notify the caller when new tag is opened or closed.\n * \n * If `generateAsync` is true - the parser will break its own execution,\n * allowing UI thread to catch up. (Only for browser environment now)\n * \n * @returns Function(chunk: String) - function that processes chunk of text\n * \n * WARNING: This may not work correctly with multi-byte unicode characters\n */\nmodule.exports = function createStreamingSVGParser(notifyTagOpen, notifyTagClose, generateAsync) {\n  let currentState = WAIT_TAG_OPEN;\n  let closeAttributeSymbol;\n  let currentTagName;\n  let currentAttributeName;\n  let lastElement;\n  let buffer;\n  let innerText;\n  if (notifyTagClose === undefined) {\n    notifyTagClose = Function.prototype; // noop\n  }\n\n  return generateAsync ? processChunkAsync : processChunkSync;\n\n  function processChunkAsync(chunk) {\n    return new Promise(resolve => iterateSymbolsAsync(chunk, 0, resolve));\n  }\n\n  function iterateSymbolsAsync(chunk, idx, resolve) {\n    let start = performance.now(); \n    let processed = 0;\n\n    while (idx < chunk.length) {\n      // Assuming each element is a symbol (i.e. this wouldn't work for unicode well).\n      processSymbol(chunk[idx]);\n\n      idx += 1;\n      processed += 1;\n      if (processed > 30000) {\n        let elapsed = performance.now() - start;\n        if (elapsed > 32) {\n          setTimeout(() => iterateSymbolsAsync(chunk, idx, resolve), 0);\n          return;\n        } \n      }\n    }\n    resolve();\n  }\n\n  function processChunkSync(chunk) {\n    return iterateSymbols(chunk, 0);\n  }\n\n  function iterateSymbols(chunk, idx) {\n    let processed = 0;\n\n    while (idx < chunk.length) {\n      // Assuming each element is a symbol (i.e. this wouldn't work for unicode well).\n      processSymbol(chunk[idx]);\n      idx += 1;\n    }\n  }\n\n  function processSymbol(ch) {\n    switch (currentState) {\n      case WAIT_TAG_OPEN: \n        if (ch === '<') currentState = READ_TAG_OR_COMMENT;\n        else if (innerText) {\n          innerText.push(ch);\n        }\n        break;\n      case WAIT_TAG_CLOSE: \n        if (ch === '>') currentState = WAIT_TAG_OPEN;\n        break;\n      case READ_TAG_OR_COMMENT: \n        if (ch === '!' || ch === '?') {\n          buffer = [ch];\n          currentState = READ_COMMENT;\n        } else if (ch === '/') {\n          if (innerText) {\n            lastElement.innerText = innerText.join('');\n            innerText = null;\n          }\n          notifyTagClose(lastElement);\n          if (lastElement) lastElement = lastElement.parent;\n          currentState = WAIT_TAG_CLOSE;\n          innerText = null;\n        } else {\n          currentState = READ_TAG;\n          buffer = [ch];\n        }\n        break;\n      case READ_COMMENT: {\n        buffer.push(ch);\n        let l = buffer.length;\n        if (buffer.length > 3 && \n          buffer[l - 1] === '>' &&\n          buffer[l - 2] === '-' &&\n          buffer[l - 3] === '-') {\n            currentState = WAIT_TAG_OPEN;\n            innerText = null;\n        } else if ((buffer[0] === '!' && (buffer.length > 1 && buffer[1] !== '-')) || // <!DOCTYPE\n           buffer[0] === '?') currentState = WAIT_TAG_CLOSE; // <?xml\n        break;\n      }\n      case READ_TAG: {\n        if (isTagNameCharacter(ch)) {\n          buffer.push(ch);\n        } else if (ch === '/') {\n          // <g/>\n          // Skip this one, as next `READ_TAG` will close it.\n        } else {\n          currentTagName = buffer.join('');\n          currentState = WAIT_ATTRIBUTE_OR_CLOSE_TAG;\n          let parent = lastElement;\n          lastElement = {\n            tagName: currentTagName,\n            attributes: new Map(),\n            parent,\n            children: []\n          }\n          if (parent) parent.children.push(lastElement);\n          if (ch === '>') finishTag();\n        }\n        break;\n      }\n      case READ_TAG_CLOSE: {\n        if (isTagNameCharacter(ch)) {\n          buffer.push(ch);\n        } else if (ch === '>') {\n          let closedTag = buffer.join('')\n          if (closedTag !== currentTagName) {\n            throw new Error('Expected ' + currentTagName + ' to be closed, but got ' + closedTag)\n          }\n        }\n\n        break;\n      }\n      case WAIT_ATTRIBUTE_OR_CLOSE_TAG: {\n        if (ch === '>') {\n          finishTag();\n        } else if (isTagNameCharacter(ch)) {\n          buffer = [ch];\n          currentState = READ_ATTRIBUTE_NAME;\n        } else {\n          buffer.push(ch);\n        }\n        break;\n      }\n      case READ_ATTRIBUTE_NAME: {\n        if (!isTagNameCharacter(ch)) {\n          currentAttributeName = buffer.join('');\n          if (ch === '=') currentState = WAIT_ATTRIBUTE_VALUE;\n          else if (ch === '>') {\n            lastElement.attributes.set(currentAttributeName, true);\n            finishTag();\n          } else currentState = WAIT_ATTRIBUTE_ASSIGNMENT_OR_NEXT_ATTRIBUTE;\n        } else {\n          buffer.push(ch);\n        }\n        break;\n      }\n      case WAIT_ATTRIBUTE_ASSIGNMENT_OR_NEXT_ATTRIBUTE: {\n        if (ch === '=') {\n          currentState = WAIT_ATTRIBUTE_VALUE;\n        } else if (isTagNameCharacter(ch)) {\n          currentState = READ_ATTRIBUTE_NAME;\n          // Case of a boolean attribute <path enabled d=... />\n          lastElement.attributes.set(buffer.join(''), true);\n          buffer = [ch];\n        } else if (ch === '>') {\n          lastElement.attributes.set(buffer.join(''), true);\n          finishTag();\n        }\n        break;\n      }\n      case WAIT_ATTRIBUTE_VALUE: {\n        if (ch === \"\\\"\" || ch === \"'\" || !isWhiteSpace(ch)) {\n          buffer = [];\n          currentState = READ_ATTRIBUTE_VALUE;\n          // not 100% accurate!\n          closeAttributeSymbol = ch;\n        }\n        // TODO: Might want to tighten validation here;\n        break;\n      }\n      case READ_ATTRIBUTE_VALUE: {\n        if (ch === closeAttributeSymbol) {\n          currentState = WAIT_ATTRIBUTE_OR_CLOSE_TAG;\n          lastElement.attributes.set(currentAttributeName, buffer.join(''));\n          currentAttributeName = null;\n          buffer = [];\n        } else {\n          buffer.push(ch);\n        }\n        break;\n      }\n    }\n  }\n\n\n  function finishTag() {\n    let l = buffer.length;\n    notifyTagOpen(lastElement); // we finished reading the attribute definition\n\n    if (l > 0 && buffer[l - 1] === '/') {\n      // a case of quick close <path />\n      notifyTagClose(lastElement);\n      // since we closed this tag, let's pop it, and wait for the sibling.\n      if (lastElement) lastElement = lastElement.parent;\n    }\n    currentState = WAIT_TAG_OPEN;\n    innerText = [];\n    currentAttributeName = null;\n  }\n}\n\nfunction isTagNameCharacter(ch) {\n  let code = ch.charCodeAt(0);\n  return (A <= code && code <= Z) || (ch === '_') || (ch === '-') || (ch === ':');\n}\n\nfunction isWhiteSpace(ch) {\n  return whitespace.test(ch);\n}\n", "/**\n * Streaming parser of numbers.\n */\nconst CharacterLookup = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9\n}\n\n/**\n * Naive parser of integer numbers. Optimized for memory consumption and\n * CPU performance. Not very strong on validation side.\n */\nclass NumberParser {\n  constructor() {\n    this.value = 0;\n    this.fractionValue = 0;\n    this.divider = 1;\n    this.exponent = 0;\n    this.isNegative = false;\n    this.hasValue = false;\n    this.hasFraction = false;\n    this.hasExponent = false\n  }\n\n  getValue() {\n    let value = this.value;\n    if (this.hasFraction) {\n      value += this.fractionValue / this.divider;\n    }\n    if (this.hasExponent) {\n      value *= Math.pow(10, this.exponent);\n    }\n    if (this.isNegative) {\n      return -value;\n    }\n    return value;\n  }\n\n  reset() {\n    this.value = 0;\n    this.fractionValue = 0;\n    this.divider = 1;\n    this.exponent = 0;\n    this.isNegative = false;\n    this.hasValue = false;\n    this.hasFraction = false;\n    this.hasExponent = false\n  }\n\n  addCharacter(ch) {\n    this.hasValue = true;\n    if (ch === '-') {\n      this.isNegative = true;\n      return;\n    }\n    if (ch === '.') {\n      if (this.hasFraction) throw new Error('Already has fractional part!');\n      this.hasFraction = true;\n      return;\n    }\n    if (ch === 'e') {\n      if (this.hasExponent) throw new Error('Already has exponent');\n      this.hasExponent = true;\n      this.exponent = 0;\n      return;\n    }\n\n    let numValue = CharacterLookup[ch];\n    if (numValue === undefined) throw new Error('Not a digit: ' + ch)\n\n    if (this.hasExponent) {\n      this.exponent = this.exponent * 10 + numValue;\n    } else if (this.hasFraction) {\n      this.fractionValue = this.fractionValue * 10 + numValue;\n      this.divider *= 10;\n    } else {\n      this.value = this.value * 10 + numValue;\n    }\n  }\n}\n\nmodule.exports = NumberParser;", "\n/**\n * Extremely fast SVG path data attribute parser. Currently\n * it doesn't support curves or arcs. Only M, L, H, V (and m, l, h, v) are\n * supported\n */\nconst NumberParser = require('./NumberParser');\n\nconst processCommand = {\n  M(points, lastNumbers) {\n    if (lastNumbers.length % 2 !== 0) {\n      throw new Error('Expected an even number of numbers for M command');\n    }\n    if (points.length === 0) {\n      // consider this to be absolute points\n      for (let i = 0; i < lastNumbers.length; i += 2) {\n        points.push([lastNumbers[i], lastNumbers[i + 1]]);\n      }\n    } else {\n      // Note: this is not true for generic case, and could/should be extended to start a new path.\n      // We are just optimizing for own sake of a single path\n      throw new Error('Only one \"Move\" command per path is expected');\n    }\n  },\n  m(points, lastNumbers) {\n    // https://www.w3.org/TR/SVG11/paths.html#PathDataMovetoCommands\n    let lx = 0, ly = 0;\n    if (points.length > 0 && lastNumbers.length > 1) {\n      let last = points[points.length - 1];\n      lx = last[0] + lastNumbers[0];\n      ly = last[1] + lastNumbers[1]; ;\n    }\n    // TODO: Likely need to break points here into two arrays.\n    for (let i = 2; i < lastNumbers.length; i += 2) {\n      let x = lx + lastNumbers[i];\n      let y = ly + lastNumbers[i + 1];\n      points.push([x, y]);\n      lx = x; ly = y;\n    }\n  },\n  // line to:\n  L(points, lastNumbers) {\n    // TODO: validate lastNumbers.length % 2 === 0\n    for (let i = 0; i < lastNumbers.length; i += 2) {\n      points.push([lastNumbers[i], lastNumbers[i + 1]]);\n    }\n  },\n  // relative line to:\n  l(points, lastNumbers) {\n    let lx = 0, ly = 0;\n    if (points.length > 0) {\n      let last = points[points.length - 1];\n      lx = last[0];\n      ly = last[1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 2) {\n      let x = lx + lastNumbers[i];\n      let y = ly + lastNumbers[i + 1];\n      points.push([x, y]);\n      lx = x; ly = y;\n    }\n  },\n  H(points, lastNumbers) {\n    let y = 0;\n    if (points.length > 0) {\n      y = points[points.length - 1][1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      let x = lastNumbers[i];\n      points.push([x, y]);\n    }\n  },\n  h(points, lastNumbers) {\n    let y = 0, lx = 0;\n    if (points.length > 0) {\n      lx = points[points.length - 1][0];\n      y = points[points.length - 1][1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      let x = lx + lastNumbers[i];\n      points.push([x, y]);\n      lx = x;\n    }\n  },\n  V(points, lastNumbers) {\n    let x = 0;\n    if (points.length > 0) {\n      x = points[points.length - 1][0];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      points.push([x, lastNumbers[i]]);\n    }\n  },\n  v(points, lastNumbers) {\n    let ly = 0, x = 0;\n    if (points.length > 0) {\n      x = points[points.length - 1][0];\n      ly = points[points.length - 1][1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      let y = ly + lastNumbers[i];\n      points.push([x, y]);\n      ly = y;\n    }\n  }\n}\n\nfunction getPointsFromPathData(d) {\n  let numParser = new NumberParser();\n  let idx = 0;\n  let l = d.length;\n  let ch;\n  let lastNumbers, lastCommand;\n  let points = [];\n  while (idx < l) {\n    ch = d[idx];\n    if (ch in processCommand) {\n      if (numParser.hasValue) {\n        lastNumbers.push(numParser.getValue())\n      }\n      numParser.reset();\n      if (lastNumbers) {\n        lastCommand(points, lastNumbers);\n      }\n      lastCommand = processCommand[ch];\n      lastNumbers = [];\n    } else if (ch === ' ' || ch === ',') {\n      if (numParser.hasValue) {\n        lastNumbers.push(numParser.getValue())\n        numParser.reset();\n      }\n      // ignore.\n    } else if (ch === 'Z' || ch === 'z') {\n      // TODO: Likely need to close the path..\n      // ignore\n    } else if (numParser.hasValue && ch === '-') {\n      // this considered to be a start of the next number.\n      lastNumbers.push(numParser.getValue())\n      numParser.reset();\n      numParser.addCharacter(ch);\n    } else {\n      numParser.addCharacter(ch);\n    }\n    idx += 1;\n  }\n  if (numParser.hasValue) {\n    lastNumbers.push(numParser.getValue());\n  }\n  if (lastNumbers) {\n    lastCommand(points, lastNumbers);\n  }\n  return points;\n}\n\nmodule.exports = getPointsFromPathData;", "module.exports = function getElementFillColor(el) {\n  return getColor(el.attributes.get('fill') || el.attributes.get('style'));\n}\n\nfunction getColor(styleValue) {\n  // TODO: could probably be done faster.\n  if (styleValue[0] === '#') {\n    if (styleValue.length === 1 + 6) {\n      // #rrggbb\n      let r = Number.parseInt(styleValue.substr(1, 2), 16);\n      let g = Number.parseInt(styleValue.substr(3, 2), 16);\n      let b = Number.parseInt(styleValue.substr(5, 2), 16);\n      return hexColor([r, g, b]);\n    }\n    if (styleValue.length === 1 + 3 || styleValue.length === 1 + 4) {\n      // #rgba\n      let rs = styleValue.substr(1, 1);\n      let gs = styleValue.substr(2, 1);\n      let bs = styleValue.substr(3, 1);\n      // ignore a\n      let r = Number.parseInt(rs + rs, 16);\n      let g = Number.parseInt(gs + gs, 16);\n      let b = Number.parseInt(bs + bs, 16);\n      return hexColor([r, g, b]);\n    }\n    throw new Error('Cannot parse this color yet ' + styleValue);\n  } else if (styleValue.startsWith('rgba')) {\n    // rgba(rr,gg,bb,a)\n    let colors = styleValue.substr(5).split(/,/).map(x => Number.parseFloat(x))\n    colors[3] = Math.round(colors[3] * 255);\n    return alphaHexColor(colors);\n  }\n  let rgb = styleValue.match(/fill:rgb\\((.+?)\\)/);\n  let rgbArray;\n  if (rgb) {\n    rgbArray = rgb[1]\n      .split(',')\n      .map((x) => Number.parseInt(x, 10))\n      .filter(finiteNumber);\n  }\n  if (!rgbArray) {\n    rgb = styleValue.match(/fill:#([0-9a-fA-F]{6})/)\n    if (rgb) {\n      rgbArray = [\n          Number.parseInt(rgb[1].substr(0, 2), 16),\n          Number.parseInt(rgb[1].substr(2, 2), 16),\n          Number.parseInt(rgb[1].substr(4, 2), 16)\n        ]\n    }\n  }\n  if (!rgbArray) {\n    rgb = styleValue.match(/fill:#([0-9a-fA-F]{3})/)\n    if (rgb) {\n      let rs = rgb[1].substr(0, 1);\n      let gs = rgb[1].substr(1, 1);\n      let bs = rgb[1].substr(2, 1);\n      rgbArray = [\n        Number.parseInt(rs + rs, 16),\n        Number.parseInt(gs + gs, 16),\n        Number.parseInt(bs + bs, 16)\n      ]\n    }\n\n  }\n  if (rgbArray) {\n    if (rgbArray.length !== 3){\n      throw new Error('Cannot parse this color yet ' + styleValue);\n    }\n    return hexColor(rgbArray);\n  }\n  console.error('Cannot parse this color yet ' + styleValue)\n  throw new Error('Cannot parse this color yet ' + styleValue);\n}\n\nfunction hexColor(arr) {\n  return arr;\n}\nfunction alphaHexColor(arr) {\n  return arr;\n}\nfunction finiteNumber(x) {\n  return Number.isFinite(x);\n}", "const createStreamingSVGParser = require('./lib/createStreamingSVGParser');\nconst getPointsFromPathData = require('./lib/getPointsFromPathData');\nconst NumberParser = require('./lib/NumberParser');\nconst getElementFillColor = require('./lib/getElementFillColor');\n\nmodule.exports = {\n  createStreamingSVGParser,\n  getPointsFromPathData,\n  NumberParser,\n\n  // Somewhat specific methods. Defining it temporarily here. May go away\n  getElementFillColor\n}"],
  "mappings": "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",
  "names": []
}
