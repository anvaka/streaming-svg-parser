{
  "version": 3,
  "sources": ["../lib/createStreamingSVGParser.js", "../lib/NumberParser.js", "../lib/getPointsFromPathData.js", "../lib/getElementFillColor.js", "../index.js"],
  "sourcesContent": ["\n// Possible states of SVG parsing\nconst WAIT_TAG_OPEN = 1;\nconst READ_TAG_OR_COMMENT = 2;\nconst READ_TAG = 3;\nconst READ_TAG_CLOSE = 4;\nconst READ_COMMENT = 5;\nconst WAIT_TAG_CLOSE = 6;\nconst WAIT_ATTRIBUTE_OR_CLOSE_TAG = 7;\nconst READ_ATTRIBUTE_NAME = 8;\nconst READ_ATTRIBUTE_VALUE = 9;\nconst WAIT_ATTRIBUTE_VALUE = 10;\nconst WAIT_ATTRIBUTE_ASSIGNMENT_OR_NEXT_ATTRIBUTE = 11;\n\nconst A = 'A'.charCodeAt(0);\nconst Z = 'z'.charCodeAt(0);\nconst whitespace = /\\s/;\n\n/**\n * Creates a new instance of the parser. Parser will consume chunk of text and will\n * notify the caller when new tag is opened or closed.\n * \n * If `generateAsync` is true - the parser will break its own execution,\n * allowing UI thread to catch up. (Only for browser environment now)\n * \n * @returns Function(chunk: String) - function that processes chunk of text\n * \n * WARNING: This may not work correctly with multi-byte unicode characters\n */\nmodule.exports = function createStreamingSVGParser(notifyTagOpen, notifyTagClose, generateAsync) {\n  let currentState = WAIT_TAG_OPEN;\n  let closeAttributeSymbol;\n  let currentTagName;\n  let currentAttributeName;\n  let lastElement;\n  let buffer;\n  let innerText;\n  if (notifyTagClose === undefined) {\n    notifyTagClose = Function.prototype; // noop\n  }\n\n  return generateAsync ? processChunkAsync : processChunkSync;\n\n  function processChunkAsync(chunk) {\n    return new Promise(resolve => iterateSymbolsAsync(chunk, 0, resolve));\n  }\n\n  function iterateSymbolsAsync(chunk, idx, resolve) {\n    let start = performance.now(); \n    let processed = 0;\n\n    while (idx < chunk.length) {\n      // Assuming each element is a symbol (i.e. this wouldn't work for unicode well).\n      processSymbol(chunk[idx]);\n\n      idx += 1;\n      processed += 1;\n      if (processed > 30000) {\n        let elapsed = performance.now() - start;\n        if (elapsed > 32) {\n          setTimeout(() => iterateSymbolsAsync(chunk, idx, resolve), 0);\n          return;\n        } \n      }\n    }\n    resolve();\n  }\n\n  function processChunkSync(chunk) {\n    return iterateSymbols(chunk, 0);\n  }\n\n  function iterateSymbols(chunk, idx) {\n    let processed = 0;\n\n    while (idx < chunk.length) {\n      // Assuming each element is a symbol (i.e. this wouldn't work for unicode well).\n      processSymbol(chunk[idx]);\n      idx += 1;\n    }\n  }\n\n  function processSymbol(ch) {\n    switch (currentState) {\n      case WAIT_TAG_OPEN: \n        if (ch === '<') currentState = READ_TAG_OR_COMMENT;\n        else if (innerText) {\n          innerText.push(ch);\n        }\n        break;\n      case WAIT_TAG_CLOSE: \n        if (ch === '>') currentState = WAIT_TAG_OPEN;\n        break;\n      case READ_TAG_OR_COMMENT: \n        if (ch === '!' || ch === '?') {\n          buffer = [ch];\n          currentState = READ_COMMENT;\n        } else if (ch === '/') {\n          if (innerText) {\n            lastElement.innerText = innerText.join('');\n            innerText = null;\n          }\n          notifyTagClose(lastElement);\n          if (lastElement) lastElement = lastElement.parent;\n          currentState = WAIT_TAG_CLOSE;\n          innerText = null;\n        } else {\n          currentState = READ_TAG;\n          buffer = [ch];\n        }\n        break;\n      case READ_COMMENT: {\n        buffer.push(ch);\n        let l = buffer.length;\n        if (buffer.length > 3 && \n          buffer[l - 1] === '>' &&\n          buffer[l - 2] === '-' &&\n          buffer[l - 3] === '-') {\n            currentState = WAIT_TAG_OPEN;\n            innerText = null;\n        } else if ((buffer[0] === '!' && (buffer.length > 1 && buffer[1] !== '-')) || // <!DOCTYPE\n           buffer[0] === '?') currentState = WAIT_TAG_CLOSE; // <?xml\n        break;\n      }\n      case READ_TAG: {\n        if (isTagNameCharacter(ch)) {\n          buffer.push(ch);\n        } else if (ch === '/') {\n          // <g/>\n          // Skip this one, as next `READ_TAG` will close it.\n        } else {\n          currentTagName = buffer.join('');\n          currentState = WAIT_ATTRIBUTE_OR_CLOSE_TAG;\n          let parent = lastElement;\n          lastElement = {\n            tagName: currentTagName,\n            attributes: new Map(),\n            parent,\n            children: []\n          }\n          if (parent) parent.children.push(lastElement);\n          if (ch === '>') finishTag();\n        }\n        break;\n      }\n      case READ_TAG_CLOSE: {\n        if (isTagNameCharacter(ch)) {\n          buffer.push(ch);\n        } else if (ch === '>') {\n          let closedTag = buffer.join('')\n          if (closedTag !== currentTagName) {\n            throw new Error('Expected ' + currentTagName + ' to be closed, but got ' + closedTag)\n          }\n        }\n\n        break;\n      }\n      case WAIT_ATTRIBUTE_OR_CLOSE_TAG: {\n        if (ch === '>') {\n          finishTag();\n        } else if (isTagNameCharacter(ch)) {\n          buffer = [ch];\n          currentState = READ_ATTRIBUTE_NAME;\n        } else {\n          buffer.push(ch);\n        }\n        break;\n      }\n      case READ_ATTRIBUTE_NAME: {\n        if (!isTagNameCharacter(ch)) {\n          currentAttributeName = buffer.join('');\n          if (ch === '=') currentState = WAIT_ATTRIBUTE_VALUE;\n          else if (ch === '>') {\n            lastElement.attributes.set(currentAttributeName, true);\n            finishTag();\n          } else currentState = WAIT_ATTRIBUTE_ASSIGNMENT_OR_NEXT_ATTRIBUTE;\n        } else {\n          buffer.push(ch);\n        }\n        break;\n      }\n      case WAIT_ATTRIBUTE_ASSIGNMENT_OR_NEXT_ATTRIBUTE: {\n        if (ch === '=') {\n          currentState = WAIT_ATTRIBUTE_VALUE;\n        } else if (isTagNameCharacter(ch)) {\n          currentState = READ_ATTRIBUTE_NAME;\n          // Case of a boolean attribute <path enabled d=... />\n          lastElement.attributes.set(buffer.join(''), true);\n          buffer = [ch];\n        } else if (ch === '>') {\n          lastElement.attributes.set(buffer.join(''), true);\n          finishTag();\n        }\n        break;\n      }\n      case WAIT_ATTRIBUTE_VALUE: {\n        if (ch === \"\\\"\" || ch === \"'\" || !isWhiteSpace(ch)) {\n          buffer = [];\n          currentState = READ_ATTRIBUTE_VALUE;\n          // not 100% accurate!\n          closeAttributeSymbol = ch;\n        }\n        // TODO: Might want to tighten validation here;\n        break;\n      }\n      case READ_ATTRIBUTE_VALUE: {\n        if (ch === closeAttributeSymbol) {\n          currentState = WAIT_ATTRIBUTE_OR_CLOSE_TAG;\n          lastElement.attributes.set(currentAttributeName, buffer.join(''));\n          currentAttributeName = null;\n          buffer = [];\n        } else {\n          buffer.push(ch);\n        }\n        break;\n      }\n    }\n  }\n\n\n  function finishTag() {\n    let l = buffer.length;\n    notifyTagOpen(lastElement); // we finished reading the attribute definition\n\n    if (l > 0 && buffer[l - 1] === '/') {\n      // a case of quick close <path />\n      notifyTagClose(lastElement);\n      // since we closed this tag, let's pop it, and wait for the sibling.\n      if (lastElement) lastElement = lastElement.parent;\n    }\n    currentState = WAIT_TAG_OPEN;\n    innerText = [];\n    currentAttributeName = null;\n  }\n}\n\nfunction isTagNameCharacter(ch) {\n  let code = ch.charCodeAt(0);\n  return (A <= code && code <= Z) || (ch === '_') || (ch === '-') || (ch === ':');\n}\n\nfunction isWhiteSpace(ch) {\n  return whitespace.test(ch);\n}\n", "/**\n * Streaming parser of numbers.\n */\nconst CharacterLookup = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9\n}\n\n/**\n * Naive parser of integer numbers. Optimized for memory consumption and\n * CPU performance. Not very strong on validation side.\n */\nclass NumberParser {\n  constructor() {\n    this.value = 0;\n    this.fractionValue = 0;\n    this.divider = 1;\n    this.exponent = 0;\n    this.isNegative = false;\n    this.hasValue = false;\n    this.hasFraction = false;\n    this.hasExponent = false\n  }\n\n  getValue() {\n    let value = this.value;\n    if (this.hasFraction) {\n      value += this.fractionValue / this.divider;\n    }\n    if (this.hasExponent) {\n      value *= Math.pow(10, this.exponent);\n    }\n    if (this.isNegative) {\n      return -value;\n    }\n    return value;\n  }\n\n  reset() {\n    this.value = 0;\n    this.fractionValue = 0;\n    this.divider = 1;\n    this.exponent = 0;\n    this.isNegative = false;\n    this.hasValue = false;\n    this.hasFraction = false;\n    this.hasExponent = false\n  }\n\n  addCharacter(ch) {\n    this.hasValue = true;\n    if (ch === '-') {\n      this.isNegative = true;\n      return;\n    }\n    if (ch === '.') {\n      if (this.hasFraction) throw new Error('Already has fractional part!');\n      this.hasFraction = true;\n      return;\n    }\n    if (ch === 'e') {\n      if (this.hasExponent) throw new Error('Already has exponent');\n      this.hasExponent = true;\n      this.exponent = 0;\n      return;\n    }\n\n    let numValue = CharacterLookup[ch];\n    if (numValue === undefined) throw new Error('Not a digit: ' + ch)\n\n    if (this.hasExponent) {\n      this.exponent = this.exponent * 10 + numValue;\n    } else if (this.hasFraction) {\n      this.fractionValue = this.fractionValue * 10 + numValue;\n      this.divider *= 10;\n    } else {\n      this.value = this.value * 10 + numValue;\n    }\n  }\n}\n\nmodule.exports = NumberParser;", "\n/**\n * Extremely fast SVG path data attribute parser. Currently\n * it doesn't support curves or arcs. Only M, L, H, V (and m, l, h, v) are\n * supported\n */\nconst NumberParser = require('./NumberParser');\n\nconst processCommand = {\n  M(points, lastNumbers) {\n    if (lastNumbers.length % 2 !== 0) {\n      throw new Error('Expected an even number of numbers for M command');\n    }\n    if (points.length === 0) {\n      // consider this to be absolute points\n      for (let i = 0; i < lastNumbers.length; i += 2) {\n        points.push([lastNumbers[i], lastNumbers[i + 1]]);\n      }\n    } else {\n      // Note: this is not true for generic case, and could/should be extended to start a new path.\n      // We are just optimizing for own sake of a single path\n      throw new Error('Only one \"Move\" command per path is expected');\n    }\n  },\n  m(points, lastNumbers) {\n    // https://www.w3.org/TR/SVG11/paths.html#PathDataMovetoCommands\n    let lx = 0, ly = 0;\n    if (points.length > 0 && lastNumbers.length > 1) {\n      let last = points[points.length - 1];\n      lx = last[0] + lastNumbers[0];\n      ly = last[1] + lastNumbers[1]; ;\n    }\n    // TODO: Likely need to break points here into two arrays.\n    for (let i = 2; i < lastNumbers.length; i += 2) {\n      let x = lx + lastNumbers[i];\n      let y = ly + lastNumbers[i + 1];\n      points.push([x, y]);\n      lx = x; ly = y;\n    }\n  },\n  // line to:\n  L(points, lastNumbers) {\n    // TODO: validate lastNumbers.length % 2 === 0\n    for (let i = 0; i < lastNumbers.length; i += 2) {\n      points.push([lastNumbers[i], lastNumbers[i + 1]]);\n    }\n  },\n  // relative line to:\n  l(points, lastNumbers) {\n    let lx = 0, ly = 0;\n    if (points.length > 0) {\n      let last = points[points.length - 1];\n      lx = last[0];\n      ly = last[1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 2) {\n      let x = lx + lastNumbers[i];\n      let y = ly + lastNumbers[i + 1];\n      points.push([x, y]);\n      lx = x; ly = y;\n    }\n  },\n  H(points, lastNumbers) {\n    let y = 0;\n    if (points.length > 0) {\n      y = points[points.length - 1][1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      let x = lastNumbers[i];\n      points.push([x, y]);\n    }\n  },\n  h(points, lastNumbers) {\n    let y = 0, lx = 0;\n    if (points.length > 0) {\n      lx = points[points.length - 1][0];\n      y = points[points.length - 1][1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      let x = lx + lastNumbers[i];\n      points.push([x, y]);\n      lx = x;\n    }\n  },\n  V(points, lastNumbers) {\n    let x = 0;\n    if (points.length > 0) {\n      x = points[points.length - 1][0];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      points.push([x, lastNumbers[i]]);\n    }\n  },\n  v(points, lastNumbers) {\n    let ly = 0, x = 0;\n    if (points.length > 0) {\n      x = points[points.length - 1][0];\n      ly = points[points.length - 1][1];\n    }\n    for (let i = 0; i < lastNumbers.length; i += 1) {\n      let y = ly + lastNumbers[i];\n      points.push([x, y]);\n      ly = y;\n    }\n  }\n}\n\nfunction getPointsFromPathData(d) {\n  let numParser = new NumberParser();\n  let idx = 0;\n  let l = d.length;\n  let ch;\n  let lastNumbers, lastCommand;\n  let points = [];\n  while (idx < l) {\n    ch = d[idx];\n    if (ch in processCommand) {\n      if (numParser.hasValue) {\n        lastNumbers.push(numParser.getValue())\n      }\n      numParser.reset();\n      if (lastNumbers) {\n        lastCommand(points, lastNumbers);\n      }\n      lastCommand = processCommand[ch];\n      lastNumbers = [];\n    } else if (ch === ' ' || ch === ',') {\n      if (numParser.hasValue) {\n        lastNumbers.push(numParser.getValue())\n        numParser.reset();\n      }\n      // ignore.\n    } else if (ch === 'Z' || ch === 'z') {\n      // TODO: Likely need to close the path..\n      // ignore\n    } else if (numParser.hasValue && ch === '-') {\n      // this considered to be a start of the next number.\n      lastNumbers.push(numParser.getValue())\n      numParser.reset();\n      numParser.addCharacter(ch);\n    } else {\n      numParser.addCharacter(ch);\n    }\n    idx += 1;\n  }\n  if (numParser.hasValue) {\n    lastNumbers.push(numParser.getValue());\n  }\n  if (lastNumbers) {\n    lastCommand(points, lastNumbers);\n  }\n  return points;\n}\n\nmodule.exports = getPointsFromPathData;", "module.exports = function getElementFillColor(el) {\n  return getColor(el.attributes.get('fill') || el.attributes.get('style'));\n}\n\nfunction getColor(styleValue) {\n  // TODO: could probably be done faster.\n  if (styleValue[0] === '#') {\n    if (styleValue.length === 1 + 6) {\n      // #rrggbb\n      let r = Number.parseInt(styleValue.substr(1, 2), 16);\n      let g = Number.parseInt(styleValue.substr(3, 2), 16);\n      let b = Number.parseInt(styleValue.substr(5, 2), 16);\n      return hexColor([r, g, b]);\n    }\n    if (styleValue.length === 1 + 3 || styleValue.length === 1 + 4) {\n      // #rgba\n      let rs = styleValue.substr(1, 1);\n      let gs = styleValue.substr(2, 1);\n      let bs = styleValue.substr(3, 1);\n      // ignore a\n      let r = Number.parseInt(rs + rs, 16);\n      let g = Number.parseInt(gs + gs, 16);\n      let b = Number.parseInt(bs + bs, 16);\n      return hexColor([r, g, b]);\n    }\n    throw new Error('Cannot parse this color yet ' + styleValue);\n  } else if (styleValue.startsWith('rgba')) {\n    // rgba(rr,gg,bb,a)\n    let colors = styleValue.substr(5).split(/,/).map(x => Number.parseFloat(x))\n    colors[3] = Math.round(colors[3] * 255);\n    return alphaHexColor(colors);\n  }\n  let rgb = styleValue.match(/fill:rgb\\((.+?)\\)/);\n  let rgbArray;\n  if (rgb) {\n    rgbArray = rgb[1]\n      .split(',')\n      .map((x) => Number.parseInt(x, 10))\n      .filter(finiteNumber);\n  }\n  if (!rgbArray) {\n    rgb = styleValue.match(/fill:#([0-9a-fA-F]{6})/)\n    if (rgb) {\n      rgbArray = [\n          Number.parseInt(rgb[1].substr(0, 2), 16),\n          Number.parseInt(rgb[1].substr(2, 2), 16),\n          Number.parseInt(rgb[1].substr(4, 2), 16)\n        ]\n    }\n  }\n  if (!rgbArray) {\n    rgb = styleValue.match(/fill:#([0-9a-fA-F]{3})/)\n    if (rgb) {\n      let rs = rgb[1].substr(0, 1);\n      let gs = rgb[1].substr(1, 1);\n      let bs = rgb[1].substr(2, 1);\n      rgbArray = [\n        Number.parseInt(rs + rs, 16),\n        Number.parseInt(gs + gs, 16),\n        Number.parseInt(bs + bs, 16)\n      ]\n    }\n\n  }\n  if (rgbArray) {\n    if (rgbArray.length !== 3){\n      throw new Error('Cannot parse this color yet ' + styleValue);\n    }\n    return hexColor(rgbArray);\n  }\n  console.error('Cannot parse this color yet ' + styleValue)\n  throw new Error('Cannot parse this color yet ' + styleValue);\n}\n\nfunction hexColor(arr) {\n  return arr;\n}\nfunction alphaHexColor(arr) {\n  return arr;\n}\nfunction finiteNumber(x) {\n  return Number.isFinite(x);\n}", "const createStreamingSVGParser = require('./lib/createStreamingSVGParser');\nconst getPointsFromPathData = require('./lib/getPointsFromPathData');\nconst NumberParser = require('./lib/NumberParser');\nconst getElementFillColor = require('./lib/getElementFillColor');\n\nmodule.exports = {\n  createStreamingSVGParser,\n  getPointsFromPathData,\n  NumberParser,\n\n  // Somewhat specific methods. Defining it temporarily here. May go away\n  getElementFillColor\n}"],
  "mappings": ";;;;;;;AAAA;AAAA;AAEA,UAAM,gBAAgB;AACtB,UAAM,sBAAsB;AAC5B,UAAM,WAAW;AACjB,UAAM,iBAAiB;AACvB,UAAM,eAAe;AACrB,UAAM,iBAAiB;AACvB,UAAM,8BAA8B;AACpC,UAAM,sBAAsB;AAC5B,UAAM,uBAAuB;AAC7B,UAAM,uBAAuB;AAC7B,UAAM,8CAA8C;AAEpD,UAAM,IAAI,IAAI,WAAW,CAAC;AAC1B,UAAM,IAAI,IAAI,WAAW,CAAC;AAC1B,UAAM,aAAa;AAanB,aAAO,UAAU,kCAAkC,eAAe,gBAAgB,eAAe;AAC/F,YAAI,eAAe;AACnB,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI;AACJ,YAAI,mBAAmB,QAAW;AAChC,2BAAiB,SAAS;AAAA,QAC5B;AAEA,eAAO,gBAAgB,oBAAoB;AAE3C,mCAA2B,OAAO;AAChC,iBAAO,IAAI,QAAQ,aAAW,oBAAoB,OAAO,GAAG,OAAO,CAAC;AAAA,QACtE;AAEA,qCAA6B,OAAO,KAAK,SAAS;AAChD,cAAI,QAAQ,YAAY,IAAI;AAC5B,cAAI,YAAY;AAEhB,iBAAO,MAAM,MAAM,QAAQ;AAEzB,0BAAc,MAAM,IAAI;AAExB,mBAAO;AACP,yBAAa;AACb,gBAAI,YAAY,KAAO;AACrB,kBAAI,UAAU,YAAY,IAAI,IAAI;AAClC,kBAAI,UAAU,IAAI;AAChB,2BAAW,MAAM,oBAAoB,OAAO,KAAK,OAAO,GAAG,CAAC;AAC5D;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA,kBAAQ;AAAA,QACV;AAEA,kCAA0B,OAAO;AAC/B,iBAAO,eAAe,OAAO,CAAC;AAAA,QAChC;AAEA,gCAAwB,OAAO,KAAK;AAClC,cAAI,YAAY;AAEhB,iBAAO,MAAM,MAAM,QAAQ;AAEzB,0BAAc,MAAM,IAAI;AACxB,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,+BAAuB,IAAI;AACzB,kBAAQ;AAAA,iBACD;AACH,kBAAI,OAAO;AAAK,+BAAe;AAAA,uBACtB,WAAW;AAClB,0BAAU,KAAK,EAAE;AAAA,cACnB;AACA;AAAA,iBACG;AACH,kBAAI,OAAO;AAAK,+BAAe;AAC/B;AAAA,iBACG;AACH,kBAAI,OAAO,OAAO,OAAO,KAAK;AAC5B,yBAAS,CAAC,EAAE;AACZ,+BAAe;AAAA,cACjB,WAAW,OAAO,KAAK;AACrB,oBAAI,WAAW;AACb,8BAAY,YAAY,UAAU,KAAK,EAAE;AACzC,8BAAY;AAAA,gBACd;AACA,+BAAe,WAAW;AAC1B,oBAAI;AAAa,gCAAc,YAAY;AAC3C,+BAAe;AACf,4BAAY;AAAA,cACd,OAAO;AACL,+BAAe;AACf,yBAAS,CAAC,EAAE;AAAA,cACd;AACA;AAAA,iBACG,cAAc;AACjB,qBAAO,KAAK,EAAE;AACd,kBAAI,IAAI,OAAO;AACf,kBAAI,OAAO,SAAS,KAClB,OAAO,IAAI,OAAO,OAClB,OAAO,IAAI,OAAO,OAClB,OAAO,IAAI,OAAO,KAAK;AACrB,+BAAe;AACf,4BAAY;AAAA,cAChB,WAAY,OAAO,OAAO,OAAQ,QAAO,SAAS,KAAK,OAAO,OAAO,QAClE,OAAO,OAAO;AAAK,+BAAe;AACrC;AAAA,YACF;AAAA,iBACK,UAAU;AACb,kBAAI,mBAAmB,EAAE,GAAG;AAC1B,uBAAO,KAAK,EAAE;AAAA,cAChB,WAAW,OAAO,KAAK;AAAA,cAGvB,OAAO;AACL,iCAAiB,OAAO,KAAK,EAAE;AAC/B,+BAAe;AACf,oBAAI,SAAS;AACb,8BAAc;AAAA,kBACZ,SAAS;AAAA,kBACT,YAAY,oBAAI,IAAI;AAAA,kBACpB;AAAA,kBACA,UAAU,CAAC;AAAA,gBACb;AACA,oBAAI;AAAQ,yBAAO,SAAS,KAAK,WAAW;AAC5C,oBAAI,OAAO;AAAK,4BAAU;AAAA,cAC5B;AACA;AAAA,YACF;AAAA,iBACK,gBAAgB;AACnB,kBAAI,mBAAmB,EAAE,GAAG;AAC1B,uBAAO,KAAK,EAAE;AAAA,cAChB,WAAW,OAAO,KAAK;AACrB,oBAAI,YAAY,OAAO,KAAK,EAAE;AAC9B,oBAAI,cAAc,gBAAgB;AAChC,wBAAM,IAAI,MAAM,cAAc,iBAAiB,4BAA4B,SAAS;AAAA,gBACtF;AAAA,cACF;AAEA;AAAA,YACF;AAAA,iBACK,6BAA6B;AAChC,kBAAI,OAAO,KAAK;AACd,0BAAU;AAAA,cACZ,WAAW,mBAAmB,EAAE,GAAG;AACjC,yBAAS,CAAC,EAAE;AACZ,+BAAe;AAAA,cACjB,OAAO;AACL,uBAAO,KAAK,EAAE;AAAA,cAChB;AACA;AAAA,YACF;AAAA,iBACK,qBAAqB;AACxB,kBAAI,CAAC,mBAAmB,EAAE,GAAG;AAC3B,uCAAuB,OAAO,KAAK,EAAE;AACrC,oBAAI,OAAO;AAAK,iCAAe;AAAA,yBACtB,OAAO,KAAK;AACnB,8BAAY,WAAW,IAAI,sBAAsB,IAAI;AACrD,4BAAU;AAAA,gBACZ;AAAO,iCAAe;AAAA,cACxB,OAAO;AACL,uBAAO,KAAK,EAAE;AAAA,cAChB;AACA;AAAA,YACF;AAAA,iBACK,6CAA6C;AAChD,kBAAI,OAAO,KAAK;AACd,+BAAe;AAAA,cACjB,WAAW,mBAAmB,EAAE,GAAG;AACjC,+BAAe;AAEf,4BAAY,WAAW,IAAI,OAAO,KAAK,EAAE,GAAG,IAAI;AAChD,yBAAS,CAAC,EAAE;AAAA,cACd,WAAW,OAAO,KAAK;AACrB,4BAAY,WAAW,IAAI,OAAO,KAAK,EAAE,GAAG,IAAI;AAChD,0BAAU;AAAA,cACZ;AACA;AAAA,YACF;AAAA,iBACK,sBAAsB;AACzB,kBAAI,OAAO,OAAQ,OAAO,OAAO,CAAC,aAAa,EAAE,GAAG;AAClD,yBAAS,CAAC;AACV,+BAAe;AAEf,uCAAuB;AAAA,cACzB;AAEA;AAAA,YACF;AAAA,iBACK,sBAAsB;AACzB,kBAAI,OAAO,sBAAsB;AAC/B,+BAAe;AACf,4BAAY,WAAW,IAAI,sBAAsB,OAAO,KAAK,EAAE,CAAC;AAChE,uCAAuB;AACvB,yBAAS,CAAC;AAAA,cACZ,OAAO;AACL,uBAAO,KAAK,EAAE;AAAA,cAChB;AACA;AAAA,YACF;AAAA;AAAA,QAEJ;AAGA,6BAAqB;AACnB,cAAI,IAAI,OAAO;AACf,wBAAc,WAAW;AAEzB,cAAI,IAAI,KAAK,OAAO,IAAI,OAAO,KAAK;AAElC,2BAAe,WAAW;AAE1B,gBAAI;AAAa,4BAAc,YAAY;AAAA,UAC7C;AACA,yBAAe;AACf,sBAAY,CAAC;AACb,iCAAuB;AAAA,QACzB;AAAA,MACF;AAEA,kCAA4B,IAAI;AAC9B,YAAI,OAAO,GAAG,WAAW,CAAC;AAC1B,eAAQ,KAAK,QAAQ,QAAQ,KAAO,OAAO,OAAS,OAAO,OAAS,OAAO;AAAA,MAC7E;AAEA,4BAAsB,IAAI;AACxB,eAAO,WAAW,KAAK,EAAE;AAAA,MAC3B;AAAA;AAAA;;;ACnPA;AAAA;AAGA,UAAM,kBAAkB;AAAA,QACtB,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACP;AAMA,UAAM,eAAN,MAAmB;AAAA,QACjB,cAAc;AACZ,eAAK,QAAQ;AACb,eAAK,gBAAgB;AACrB,eAAK,UAAU;AACf,eAAK,WAAW;AAChB,eAAK,aAAa;AAClB,eAAK,WAAW;AAChB,eAAK,cAAc;AACnB,eAAK,cAAc;AAAA,QACrB;AAAA,QAEA,WAAW;AACT,cAAI,QAAQ,KAAK;AACjB,cAAI,KAAK,aAAa;AACpB,qBAAS,KAAK,gBAAgB,KAAK;AAAA,UACrC;AACA,cAAI,KAAK,aAAa;AACpB,qBAAS,KAAK,IAAI,IAAI,KAAK,QAAQ;AAAA,UACrC;AACA,cAAI,KAAK,YAAY;AACnB,mBAAO,CAAC;AAAA,UACV;AACA,iBAAO;AAAA,QACT;AAAA,QAEA,QAAQ;AACN,eAAK,QAAQ;AACb,eAAK,gBAAgB;AACrB,eAAK,UAAU;AACf,eAAK,WAAW;AAChB,eAAK,aAAa;AAClB,eAAK,WAAW;AAChB,eAAK,cAAc;AACnB,eAAK,cAAc;AAAA,QACrB;AAAA,QAEA,aAAa,IAAI;AACf,eAAK,WAAW;AAChB,cAAI,OAAO,KAAK;AACd,iBAAK,aAAa;AAClB;AAAA,UACF;AACA,cAAI,OAAO,KAAK;AACd,gBAAI,KAAK;AAAa,oBAAM,IAAI,MAAM,8BAA8B;AACpE,iBAAK,cAAc;AACnB;AAAA,UACF;AACA,cAAI,OAAO,KAAK;AACd,gBAAI,KAAK;AAAa,oBAAM,IAAI,MAAM,sBAAsB;AAC5D,iBAAK,cAAc;AACnB,iBAAK,WAAW;AAChB;AAAA,UACF;AAEA,cAAI,WAAW,gBAAgB;AAC/B,cAAI,aAAa;AAAW,kBAAM,IAAI,MAAM,kBAAkB,EAAE;AAEhE,cAAI,KAAK,aAAa;AACpB,iBAAK,WAAW,KAAK,WAAW,KAAK;AAAA,UACvC,WAAW,KAAK,aAAa;AAC3B,iBAAK,gBAAgB,KAAK,gBAAgB,KAAK;AAC/C,iBAAK,WAAW;AAAA,UAClB,OAAO;AACL,iBAAK,QAAQ,KAAK,QAAQ,KAAK;AAAA,UACjC;AAAA,QACF;AAAA,MACF;AAEA,aAAO,UAAU;AAAA;AAAA;;;ACzFjB;AAAA;AAMA,UAAM,eAAe;AAErB,UAAM,iBAAiB;AAAA,QACrB,EAAE,QAAQ,aAAa;AACrB,cAAI,YAAY,SAAS,MAAM,GAAG;AAChC,kBAAM,IAAI,MAAM,kDAAkD;AAAA,UACpE;AACA,cAAI,OAAO,WAAW,GAAG;AAEvB,qBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,qBAAO,KAAK,CAAC,YAAY,IAAI,YAAY,IAAI,EAAE,CAAC;AAAA,YAClD;AAAA,UACF,OAAO;AAGL,kBAAM,IAAI,MAAM,8CAA8C;AAAA,UAChE;AAAA,QACF;AAAA,QACA,EAAE,QAAQ,aAAa;AAErB,cAAI,KAAK,GAAG,KAAK;AACjB,cAAI,OAAO,SAAS,KAAK,YAAY,SAAS,GAAG;AAC/C,gBAAI,OAAO,OAAO,OAAO,SAAS;AAClC,iBAAK,KAAK,KAAK,YAAY;AAC3B,iBAAK,KAAK,KAAK,YAAY;AAAI;AAAA,UACjC;AAEA,mBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,gBAAI,IAAI,KAAK,YAAY;AACzB,gBAAI,IAAI,KAAK,YAAY,IAAI;AAC7B,mBAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AAClB,iBAAK;AAAG,iBAAK;AAAA,UACf;AAAA,QACF;AAAA,QAEA,EAAE,QAAQ,aAAa;AAErB,mBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,mBAAO,KAAK,CAAC,YAAY,IAAI,YAAY,IAAI,EAAE,CAAC;AAAA,UAClD;AAAA,QACF;AAAA,QAEA,EAAE,QAAQ,aAAa;AACrB,cAAI,KAAK,GAAG,KAAK;AACjB,cAAI,OAAO,SAAS,GAAG;AACrB,gBAAI,OAAO,OAAO,OAAO,SAAS;AAClC,iBAAK,KAAK;AACV,iBAAK,KAAK;AAAA,UACZ;AACA,mBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,gBAAI,IAAI,KAAK,YAAY;AACzB,gBAAI,IAAI,KAAK,YAAY,IAAI;AAC7B,mBAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AAClB,iBAAK;AAAG,iBAAK;AAAA,UACf;AAAA,QACF;AAAA,QACA,EAAE,QAAQ,aAAa;AACrB,cAAI,IAAI;AACR,cAAI,OAAO,SAAS,GAAG;AACrB,gBAAI,OAAO,OAAO,SAAS,GAAG;AAAA,UAChC;AACA,mBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,gBAAI,IAAI,YAAY;AACpB,mBAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AAAA,UACpB;AAAA,QACF;AAAA,QACA,EAAE,QAAQ,aAAa;AACrB,cAAI,IAAI,GAAG,KAAK;AAChB,cAAI,OAAO,SAAS,GAAG;AACrB,iBAAK,OAAO,OAAO,SAAS,GAAG;AAC/B,gBAAI,OAAO,OAAO,SAAS,GAAG;AAAA,UAChC;AACA,mBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,gBAAI,IAAI,KAAK,YAAY;AACzB,mBAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AAClB,iBAAK;AAAA,UACP;AAAA,QACF;AAAA,QACA,EAAE,QAAQ,aAAa;AACrB,cAAI,IAAI;AACR,cAAI,OAAO,SAAS,GAAG;AACrB,gBAAI,OAAO,OAAO,SAAS,GAAG;AAAA,UAChC;AACA,mBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,mBAAO,KAAK,CAAC,GAAG,YAAY,EAAE,CAAC;AAAA,UACjC;AAAA,QACF;AAAA,QACA,EAAE,QAAQ,aAAa;AACrB,cAAI,KAAK,GAAG,IAAI;AAChB,cAAI,OAAO,SAAS,GAAG;AACrB,gBAAI,OAAO,OAAO,SAAS,GAAG;AAC9B,iBAAK,OAAO,OAAO,SAAS,GAAG;AAAA,UACjC;AACA,mBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK,GAAG;AAC9C,gBAAI,IAAI,KAAK,YAAY;AACzB,mBAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AAClB,iBAAK;AAAA,UACP;AAAA,QACF;AAAA,MACF;AAEA,qCAA+B,GAAG;AAChC,YAAI,YAAY,IAAI,aAAa;AACjC,YAAI,MAAM;AACV,YAAI,IAAI,EAAE;AACV,YAAI;AACJ,YAAI,aAAa;AACjB,YAAI,SAAS,CAAC;AACd,eAAO,MAAM,GAAG;AACd,eAAK,EAAE;AACP,cAAI,MAAM,gBAAgB;AACxB,gBAAI,UAAU,UAAU;AACtB,0BAAY,KAAK,UAAU,SAAS,CAAC;AAAA,YACvC;AACA,sBAAU,MAAM;AAChB,gBAAI,aAAa;AACf,0BAAY,QAAQ,WAAW;AAAA,YACjC;AACA,0BAAc,eAAe;AAC7B,0BAAc,CAAC;AAAA,UACjB,WAAW,OAAO,OAAO,OAAO,KAAK;AACnC,gBAAI,UAAU,UAAU;AACtB,0BAAY,KAAK,UAAU,SAAS,CAAC;AACrC,wBAAU,MAAM;AAAA,YAClB;AAAA,UAEF,WAAW,OAAO,OAAO,OAAO,KAAK;AAAA,UAGrC,WAAW,UAAU,YAAY,OAAO,KAAK;AAE3C,wBAAY,KAAK,UAAU,SAAS,CAAC;AACrC,sBAAU,MAAM;AAChB,sBAAU,aAAa,EAAE;AAAA,UAC3B,OAAO;AACL,sBAAU,aAAa,EAAE;AAAA,UAC3B;AACA,iBAAO;AAAA,QACT;AACA,YAAI,UAAU,UAAU;AACtB,sBAAY,KAAK,UAAU,SAAS,CAAC;AAAA,QACvC;AACA,YAAI,aAAa;AACf,sBAAY,QAAQ,WAAW;AAAA,QACjC;AACA,eAAO;AAAA,MACT;AAEA,aAAO,UAAU;AAAA;AAAA;;;AC1JjB;AAAA;AAAA,aAAO,UAAU,6BAA6B,IAAI;AAChD,eAAO,SAAS,GAAG,WAAW,IAAI,MAAM,KAAK,GAAG,WAAW,IAAI,OAAO,CAAC;AAAA,MACzE;AAEA,wBAAkB,YAAY;AAE5B,YAAI,WAAW,OAAO,KAAK;AACzB,cAAI,WAAW,WAAW,IAAI,GAAG;AAE/B,gBAAI,IAAI,OAAO,SAAS,WAAW,OAAO,GAAG,CAAC,GAAG,EAAE;AACnD,gBAAI,IAAI,OAAO,SAAS,WAAW,OAAO,GAAG,CAAC,GAAG,EAAE;AACnD,gBAAI,IAAI,OAAO,SAAS,WAAW,OAAO,GAAG,CAAC,GAAG,EAAE;AACnD,mBAAO,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,UAC3B;AACA,cAAI,WAAW,WAAW,IAAI,KAAK,WAAW,WAAW,IAAI,GAAG;AAE9D,gBAAI,KAAK,WAAW,OAAO,GAAG,CAAC;AAC/B,gBAAI,KAAK,WAAW,OAAO,GAAG,CAAC;AAC/B,gBAAI,KAAK,WAAW,OAAO,GAAG,CAAC;AAE/B,gBAAI,IAAI,OAAO,SAAS,KAAK,IAAI,EAAE;AACnC,gBAAI,IAAI,OAAO,SAAS,KAAK,IAAI,EAAE;AACnC,gBAAI,IAAI,OAAO,SAAS,KAAK,IAAI,EAAE;AACnC,mBAAO,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,UAC3B;AACA,gBAAM,IAAI,MAAM,iCAAiC,UAAU;AAAA,QAC7D,WAAW,WAAW,WAAW,MAAM,GAAG;AAExC,cAAI,SAAS,WAAW,OAAO,CAAC,EAAE,MAAM,GAAG,EAAE,IAAI,OAAK,OAAO,WAAW,CAAC,CAAC;AAC1E,iBAAO,KAAK,KAAK,MAAM,OAAO,KAAK,GAAG;AACtC,iBAAO,cAAc,MAAM;AAAA,QAC7B;AACA,YAAI,MAAM,WAAW,MAAM,mBAAmB;AAC9C,YAAI;AACJ,YAAI,KAAK;AACP,qBAAW,IAAI,GACZ,MAAM,GAAG,EACT,IAAI,CAAC,MAAM,OAAO,SAAS,GAAG,EAAE,CAAC,EACjC,OAAO,YAAY;AAAA,QACxB;AACA,YAAI,CAAC,UAAU;AACb,gBAAM,WAAW,MAAM,wBAAwB;AAC/C,cAAI,KAAK;AACP,uBAAW;AAAA,cACP,OAAO,SAAS,IAAI,GAAG,OAAO,GAAG,CAAC,GAAG,EAAE;AAAA,cACvC,OAAO,SAAS,IAAI,GAAG,OAAO,GAAG,CAAC,GAAG,EAAE;AAAA,cACvC,OAAO,SAAS,IAAI,GAAG,OAAO,GAAG,CAAC,GAAG,EAAE;AAAA,YACzC;AAAA,UACJ;AAAA,QACF;AACA,YAAI,CAAC,UAAU;AACb,gBAAM,WAAW,MAAM,wBAAwB;AAC/C,cAAI,KAAK;AACP,gBAAI,KAAK,IAAI,GAAG,OAAO,GAAG,CAAC;AAC3B,gBAAI,KAAK,IAAI,GAAG,OAAO,GAAG,CAAC;AAC3B,gBAAI,KAAK,IAAI,GAAG,OAAO,GAAG,CAAC;AAC3B,uBAAW;AAAA,cACT,OAAO,SAAS,KAAK,IAAI,EAAE;AAAA,cAC3B,OAAO,SAAS,KAAK,IAAI,EAAE;AAAA,cAC3B,OAAO,SAAS,KAAK,IAAI,EAAE;AAAA,YAC7B;AAAA,UACF;AAAA,QAEF;AACA,YAAI,UAAU;AACZ,cAAI,SAAS,WAAW,GAAE;AACxB,kBAAM,IAAI,MAAM,iCAAiC,UAAU;AAAA,UAC7D;AACA,iBAAO,SAAS,QAAQ;AAAA,QAC1B;AACA,gBAAQ,MAAM,iCAAiC,UAAU;AACzD,cAAM,IAAI,MAAM,iCAAiC,UAAU;AAAA,MAC7D;AAEA,wBAAkB,KAAK;AACrB,eAAO;AAAA,MACT;AACA,6BAAuB,KAAK;AAC1B,eAAO;AAAA,MACT;AACA,4BAAsB,GAAG;AACvB,eAAO,OAAO,SAAS,CAAC;AAAA,MAC1B;AAAA;AAAA;;;AClFA;AAAA;AAAA,UAAM,2BAA2B;AACjC,UAAM,wBAAwB;AAC9B,UAAM,eAAe;AACrB,UAAM,sBAAsB;AAE5B,aAAO,UAAU;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QAGA;AAAA,MACF;AAAA;AAAA;",
  "names": []
}
